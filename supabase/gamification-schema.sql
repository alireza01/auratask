-- Enhanced user settings for gamification
ALTER TABLE public.user_settings 
ADD COLUMN IF NOT EXISTS level_up_xp_threshold integer DEFAULT 100,
ADD COLUMN IF NOT EXISTS current_streak integer DEFAULT 0,
ADD COLUMN IF NOT EXISTS longest_streak integer DEFAULT 0,
ADD COLUMN IF NOT EXISTS last_task_completed_at timestamp with time zone,
ADD COLUMN IF NOT EXISTS total_tasks_completed integer DEFAULT 0,
ADD COLUMN IF NOT EXISTS total_time_saved_minutes integer DEFAULT 0;

-- Achievements table
CREATE TABLE IF NOT EXISTS public.achievements (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL UNIQUE,
    description text NOT NULL,
    icon_name text NOT NULL,
    reward_points integer NOT NULL DEFAULT 0,
    category text NOT NULL DEFAULT 'general',
    rarity text NOT NULL DEFAULT 'common' CHECK (rarity IN ('common', 'rare', 'epic', 'legendary')),
    created_at timestamp with time zone DEFAULT now() NOT NULL
);

-- User achievements junction table
CREATE TABLE IF NOT EXISTS public.user_achievements (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
    achievement_id bigint REFERENCES public.achievements(id) ON DELETE CASCADE,
    unlocked_at timestamp with time zone DEFAULT now() NOT NULL,
    UNIQUE(user_id, achievement_id)
);

-- RLS policies
ALTER TABLE public.achievements ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_achievements ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Anyone can view achievements" ON public.achievements FOR SELECT USING (true);

CREATE POLICY "Users can view their own achievements" ON public.user_achievements 
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "System can insert user achievements" ON public.user_achievements 
    FOR INSERT WITH CHECK (true);

-- Insert default achievements
INSERT INTO public.achievements (name, description, icon_name, reward_points, category, rarity) VALUES
('first_task', 'اولین وظیفه', 'اولین وظیفه خود را تکمیل کنید', 'Trophy', 50, 'tasks', 'common'),
('task_novice', 'تازه‌کار وظایف', '10 وظیفه تکمیل کنید', 'Target', 100, 'tasks', 'common'),
('task_apprentice', 'شاگرد وظایف', '25 وظیفه تکمیل کنید', 'Award', 200, 'tasks', 'rare'),
('task_expert', 'متخصص وظایف', '50 وظیفه تکمیل کنید', 'Crown', 500, 'tasks', 'epic'),
('task_master', 'استاد وظایف', '100 وظیفه تکمیل کنید', 'Gem', 1000, 'tasks', 'legendary'),
('streak_starter', 'شروع‌کننده', '3 روز پیاپی وظیفه تکمیل کنید', 'Flame', 150, 'streaks', 'common'),
('streak_keeper', 'نگه‌دارنده', '7 روز پیاپی وظیفه تکمیل کنید', 'Fire', 300, 'streaks', 'rare'),
('streak_master', 'استاد تداوم', '30 روز پیاپی وظیفه تکمیل کنید', 'Zap', 1000, 'streaks', 'epic'),
('night_owl', 'جغد شبگرد', 'بعد از نیمه‌شب وظیفه تکمیل کنید', 'Moon', 100, 'special', 'rare'),
('early_bird', 'سحرخیز', 'قبل از 6 صبح وظیفه تکمیل کنید', 'Sun', 100, 'special', 'rare'),
('speed_demon', 'شیطان سرعت', 'در کمتر از 5 دقیقه وظیفه تکمیل کنید', 'Zap', 200, 'special', 'epic'),
('ai_enthusiast', 'علاقه‌مند AI', '20 وظیفه با کمک هوش مصنوعی تکمیل کنید', 'Brain', 300, 'ai', 'rare'),
('organizer', 'سازمان‌دهنده', '5 گروه وظیفه ایجاد کنید', 'FolderOpen', 150, 'organization', 'common'),
('perfectionist', 'کمال‌گرا', '10 وظیفه بدون استفاده از AI تکمیل کنید', 'Star', 250, 'special', 'rare'),
('social_butterfly', 'پروانه اجتماعی', 'در تابلوی رهبری قرار بگیرید', 'Users', 500, 'social', 'epic')
ON CONFLICT (name) DO NOTHING;

-- Function to check and award achievements
CREATE OR REPLACE FUNCTION public.check_and_award_achievements(p_user_id uuid)
RETURNS void AS $$
DECLARE
    user_stats record;
    achievement record;
BEGIN
    -- Get user statistics
    SELECT 
        us.total_tasks_completed,
        us.current_streak,
        us.longest_streak,
        us.aura_points,
        COUNT(CASE WHEN t.ai_generated = true THEN 1 END) as ai_tasks,
        COUNT(CASE WHEN t.ai_generated = false THEN 1 END) as manual_tasks,
        COUNT(DISTINCT t.group_id) as groups_created
    INTO user_stats
    FROM public.user_settings us
    LEFT JOIN public.tasks t ON t.user_id = p_user_id AND t.is_completed = true
    WHERE us.id = p_user_id
    GROUP BY us.id, us.total_tasks_completed, us.current_streak, us.longest_streak, us.aura_points;

    -- Check each achievement
    FOR achievement IN SELECT * FROM public.achievements LOOP
        -- Skip if user already has this achievement
        IF EXISTS (SELECT 1 FROM public.user_achievements WHERE user_id = p_user_id AND achievement_id = achievement.id) THEN
            CONTINUE;
        END IF;

        -- Check achievement conditions
        CASE achievement.name
            WHEN 'first_task' THEN
                IF user_stats.total_tasks_completed >= 1 THEN
                    INSERT INTO public.user_achievements (user_id, achievement_id) VALUES (p_user_id, achievement.id);
                END IF;
            WHEN 'task_novice' THEN
                IF user_stats.total_tasks_completed >= 10 THEN
                    INSERT INTO public.user_achievements (user_id, achievement_id) VALUES (p_user_id, achievement.id);
                END IF;
            WHEN 'task_apprentice' THEN
                IF user_stats.total_tasks_completed >= 25 THEN
                    INSERT INTO public.user_achievements (user_id, achievement_id) VALUES (p_user_id, achievement.id);
                END IF;
            WHEN 'task_expert' THEN
                IF user_stats.total_tasks_completed >= 50 THEN
                    INSERT INTO public.user_achievements (user_id, achievement_id) VALUES (p_user_id, achievement.id);
                END IF;
            WHEN 'task_master' THEN
                IF user_stats.total_tasks_completed >= 100 THEN
                    INSERT INTO public.user_achievements (user_id, achievement_id) VALUES (p_user_id, achievement.id);
                END IF;
            WHEN 'streak_starter' THEN
                IF user_stats.current_streak >= 3 THEN
                    INSERT INTO public.user_achievements (user_id, achievement_id) VALUES (p_user_id, achievement.id);
                END IF;
            WHEN 'streak_keeper' THEN
                IF user_stats.current_streak >= 7 THEN
                    INSERT INTO public.user_achievements (user_id, achievement_id) VALUES (p_user_id, achievement.id);
                END IF;
            WHEN 'streak_master' THEN
                IF user_stats.current_streak >= 30 THEN
                    INSERT INTO public.user_achievements (user_id, achievement_id) VALUES (p_user_id, achievement.id);
                END IF;
            WHEN 'ai_enthusiast' THEN
                IF user_stats.ai_tasks >= 20 THEN
                    INSERT INTO public.user_achievements (user_id, achievement_id) VALUES (p_user_id, achievement.id);
                END IF;
            WHEN 'organizer' THEN
                IF user_stats.groups_created >= 5 THEN
                    INSERT INTO public.user_achievements (user_id, achievement_id) VALUES (p_user_id, achievement.id);
                END IF;
            WHEN 'perfectionist' THEN
                IF user_stats.manual_tasks >= 10 THEN
                    INSERT INTO public.user_achievements (user_id, achievement_id) VALUES (p_user_id, achievement.id);
                END IF;
            ELSE
                -- Skip unknown achievements
                CONTINUE;
        END CASE;
    END LOOP;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to update streaks
CREATE OR REPLACE FUNCTION public.update_user_streak(p_user_id uuid)
RETURNS void AS $$
DECLARE
    last_completion timestamp with time zone;
    current_date_start timestamp with time zone;
    yesterday_start timestamp with time zone;
BEGIN
    -- Get current date boundaries
    current_date_start := date_trunc('day', now());
    yesterday_start := current_date_start - interval '1 day';
    
    -- Get user's last task completion
    SELECT last_task_completed_at INTO last_completion
    FROM public.user_settings
    WHERE id = p_user_id;
    
    -- If no previous completion or it was before yesterday, reset streak
    IF last_completion IS NULL OR last_completion < yesterday_start THEN
        UPDATE public.user_settings 
        SET current_streak = 1,
            last_task_completed_at = now()
        WHERE id = p_user_id;
    -- If last completion was yesterday, increment streak
    ELSIF last_completion >= yesterday_start AND last_completion < current_date_start THEN
        UPDATE public.user_settings 
        SET current_streak = current_streak + 1,
            longest_streak = GREATEST(longest_streak, current_streak + 1),
            last_task_completed_at = now()
        WHERE id = p_user_id;
    -- If completion was today, just update timestamp
    ELSIF last_completion >= current_date_start THEN
        UPDATE public.user_settings 
        SET last_task_completed_at = now()
        WHERE id = p_user_id;
    END IF;
    
    -- Update total tasks completed
    UPDATE public.user_settings 
    SET total_tasks_completed = total_tasks_completed + 1
    WHERE id = p_user_id;
    
    -- Check for new achievements
    PERFORM public.check_and_award_achievements(p_user_id);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to calculate next level XP requirement
CREATE OR REPLACE FUNCTION public.calculate_next_level_xp(current_level integer)
RETURNS integer AS $$
BEGIN
    RETURN FLOOR(100 * POWER(current_level, 1.5));
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Function to handle level ups
CREATE OR REPLACE FUNCTION public.check_level_up(p_user_id uuid)
RETURNS boolean AS $$
DECLARE
    user_settings record;
    next_level_xp integer;
    leveled_up boolean := false;
BEGIN
    SELECT * INTO user_settings FROM public.user_settings WHERE id = p_user_id;
    
    LOOP
        next_level_xp := public.calculate_next_level_xp(user_settings.level);
        
        IF user_settings.aura_points >= next_level_xp THEN
            -- Level up!
            UPDATE public.user_settings 
            SET level = level + 1,
                level_up_xp_threshold = public.calculate_next_level_xp(level + 1)
            WHERE id = p_user_id;
            
            user_settings.level := user_settings.level + 1;
            user_settings.level_up_xp_threshold := public.calculate_next_level_xp(user_settings.level);
            leveled_up := true;
        ELSE
            EXIT;
        END IF;
    END LOOP;
    
    RETURN leveled_up;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
